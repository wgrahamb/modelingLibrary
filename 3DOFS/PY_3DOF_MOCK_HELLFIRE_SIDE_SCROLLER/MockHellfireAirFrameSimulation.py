
# Python libraries.
import numpy as np
from numpy import array as npa
from numpy import linalg as la
import pandas as pd
import matplotlib.pyplot as plt
from ambiance import Atmosphere as atm
from classes.ATM1976 import ATM1976

"""

MOCK HELLFIRE DIMENSIONS

REFERENCE_DIAMETER 0.18 M
REFERENCE_LENGTH 1.6 M
NOSE_LENGTH 0.249733 M
WING_SPAN 66.1175 MM
WING_TIP_CHORD 91.047 MM
WING_ROOT_CHORD 0.123564 M
TAIL_SPAN 71.3548 MM
TAIL_TIP_CHORD 0.387894 M
TAIL_ROOT_CHORD 0.48084 M
DISTANCE_FROM_BASE_OF_NOSE_TO_WING 0.323925 M
STARTING_CG_FROM_NOSE 0.644605 m
UNCORRECTED_CENTER_OF_DEFLECTION_FROM_NOSE 1.8059 M
UNCORRECTED_REFERENCE_LENGTH 1.85026 m

"""

# Constants.
TIME_STEP = 0.001 # Seconds.
MAX_TIME = 10 # Seconds.
MM_TO_M = 1.0 / 1000.0
RAD_TO_DEG = 57.2957795130823
ALTITUDE = 1000 # Meters.
AIRSPEED = 180 # Meters per second.
FIN_DEFLECTION_DEGREES = 5 # Degrees.
FIN_DEFLECTION_RADIANS = np.radians(FIN_DEFLECTION_DEGREES) # Radians.
SPEED_OF_SOUND = 343 # Meters per second.
STANDARD_GRAVITY = 9.81 # Meters per second squared.
REFERENCE_DIAMETER = 0.18 # Meters.
NOSE_LENGTH = 0.249733 # Meters.

# Gonna leave uncorrected and see what happens.
# REFERENCE_LENGTH = 1.6 # Meters.
REFERENCE_LENGTH = 1.85026 # Meters.

WING_HALF_SPAN = 66.1175 * MM_TO_M / 2.0 # Meters.
WING_TIP_CHORD = 91.047 * MM_TO_M # Meters.
WING_ROOT_CHORD = 0.123564 # Meters.
TAIL_HALF_SPAN = 71.3548 * MM_TO_M / 2.0 # Meters.
TAIL_TIP_CHORD = 0.387894 # Meters.
TAIL_ROOT_CHORD = 0.48084 # Meters.
DISTANCE_FROM_BASE_OF_NOSE_TO_WING = 0.323925 # Meters.
STARTING_CG_FROM_NOSE =  0.644605 # Meters.
LAST_CG_FROM_NOSE =  NOSE_LENGTH # Meters.

# Gonna leave uncorrected and see what happens.
# CENTER_OF_DEFLECTION_FROM_NOSE = 1.8059 - NOSE_LENGTH # Meters (correction here due to oversight in drawing).
CENTER_OF_DEFLECTION_FROM_NOSE = 1.8059 # Meters.

MASS = 45 # Kilograms.

# CALCULATIONS OF CONSTANTS FOR LINEAR EQUATIONS OF MOTION AND DIFFERENTIAL EQUATIONS OF MOTION
WING_AREA = 0.5 * WING_HALF_SPAN * (WING_TIP_CHORD + WING_ROOT_CHORD) # Meters squared.
TAIL_AREA = 0.5 * TAIL_HALF_SPAN * (TAIL_TIP_CHORD + TAIL_ROOT_CHORD) # Meters squared.
REFERENCE_AREA = np.pi * (REFERENCE_DIAMETER ** 2) / 4 # Meters squared.
NOSE_AREA = NOSE_LENGTH * REFERENCE_DIAMETER # Meters squared.
PLANFORM_AREA = (REFERENCE_LENGTH - NOSE_LENGTH) * REFERENCE_DIAMETER + 0.667 * NOSE_LENGTH * REFERENCE_DIAMETER # Meters squared.
MACHSPEED = AIRSPEED / SPEED_OF_SOUND # Non dimensional.
if MACHSPEED > 1:
	BETA = np.sqrt(MACHSPEED ** 2 - 1) # Non dimensional.
else:
	BETA = MACHSPEED # Non dimensional.
NOSE_CENTER_OF_PRESSURE = 0.67 * NOSE_LENGTH # Meters.
WING_CENTER_OF_PRESSURE = NOSE_LENGTH + DISTANCE_FROM_BASE_OF_NOSE_TO_WING + 0.7 * WING_ROOT_CHORD - 0.2 * WING_TIP_CHORD # Meters.
AN = 0.67 * NOSE_LENGTH * REFERENCE_DIAMETER # Meters squared.
AB = (REFERENCE_LENGTH - NOSE_LENGTH) * REFERENCE_DIAMETER # Meters squared.
BODY_CENTER_OF_PRESSURE = (0.67 * AN * NOSE_LENGTH + AB * (NOSE_LENGTH + 0.5 * (REFERENCE_LENGTH - NOSE_LENGTH))) / (AN + AB) # Meters.

ATMOS = ATM1976()
ATMOS.update(ALTITUDE, AIRSPEED)
RHO = ATMOS.rho # Pascals.
DYNAMIC_PRESSURE = ATMOS.q # Pascals.
TRANSVERSE_MOMENT_OF_INERTIA = (MASS * (3 * ((0.5 * REFERENCE_DIAMETER) ** 2) + REFERENCE_LENGTH ** 2)) / (12) # Kilograms times meters squared.

# STARTING CONDITIONS FOR LINEAR EQUATIONS OF MOTION LOOP.
TOF = 0.0 # Seconds.
THETA_DOT = 0.0 # Radians per second.
THETA = 0.0 # Radians.
NORMAL_ACCEL = 0.0 # Meters per second squared.
POSITION = ALTITUDE # Meters.
ALPHA_DOT = 0.0 # Radians per second.
ALPHA = 0.0 # Radians.

LINEAR_EQNS_OF_MOTION_DICT = {
	"TOF": [],
	"THETA_DOT": [],
	"THETA": [],
	"NORMAL_ACCEL": [],
	"POSITION": [],
	"ALPHA_DOT": [],
	"ALPHA": []
}

while TOF <= MAX_TIME:

	# ITERATE TIME OF FLIGHT
	TOF += TIME_STEP # Seconds.

	# NORMAL COEFFICIENT AND PITCHING MOMENT COEFFICIENT CALCULATION, NON DIMENSIONAL.
	CN = 2 * ALPHA + (1.5 * PLANFORM_AREA * ALPHA * ALPHA) / REFERENCE_AREA + (8 * WING_AREA * ALPHA) / (BETA * REFERENCE_AREA) + (8 * TAIL_AREA * (ALPHA + FIN_DEFLECTION_RADIANS)) / (BETA * REFERENCE_AREA)
	CM = 2 * ALPHA * ((LAST_CG_FROM_NOSE - NOSE_CENTER_OF_PRESSURE) / REFERENCE_DIAMETER) + ((1.5 * PLANFORM_AREA * ALPHA * ALPHA) / REFERENCE_AREA) * ((LAST_CG_FROM_NOSE - BODY_CENTER_OF_PRESSURE) / REFERENCE_DIAMETER) + ((8 * WING_AREA * ALPHA) / (BETA * REFERENCE_AREA)) * ((LAST_CG_FROM_NOSE - WING_CENTER_OF_PRESSURE) / REFERENCE_DIAMETER) + ((8 * TAIL_AREA * (ALPHA + FIN_DEFLECTION_RADIANS)) / (BETA * REFERENCE_AREA)) * ((LAST_CG_FROM_NOSE - CENTER_OF_DEFLECTION_FROM_NOSE) / REFERENCE_DIAMETER)

	# UPDATE SIMULATION PARAMETERS
	THETA_DOT_DOT = (DYNAMIC_PRESSURE * REFERENCE_AREA * REFERENCE_DIAMETER * CM) / TRANSVERSE_MOMENT_OF_INERTIA # Radians per second squared.
	THETA_DOT += THETA_DOT_DOT * TIME_STEP # Radians per second.
	THETA += THETA_DOT * TIME_STEP # Radians.
	NORMAL_ACCEL = (DYNAMIC_PRESSURE * REFERENCE_AREA * CN) / MASS # Meters per second squared.
	POSITION += (AIRSPEED + (NORMAL_ACCEL * TIME_STEP)) * TIME_STEP
	ALPHA_DOT = THETA_DOT - (NORMAL_ACCEL / AIRSPEED) # Radians per second.
	ALPHA += ALPHA_DOT * TIME_STEP # Radians.
	
	# STORE DATA AT CURRENT CONDITIONS
	LINEAR_EQNS_OF_MOTION_DICT["TOF"].append(TOF)
	LINEAR_EQNS_OF_MOTION_DICT["THETA_DOT"].append(THETA_DOT)
	LINEAR_EQNS_OF_MOTION_DICT["THETA"].append(THETA)
	LINEAR_EQNS_OF_MOTION_DICT["NORMAL_ACCEL"].append(NORMAL_ACCEL)
	LINEAR_EQNS_OF_MOTION_DICT["POSITION"].append(POSITION)
	LINEAR_EQNS_OF_MOTION_DICT["ALPHA_DOT"].append(ALPHA_DOT)
	LINEAR_EQNS_OF_MOTION_DICT["ALPHA"].append(ALPHA)

# OUTPUT
print(f"LINEAR EQUATIONS OF MOTION FINISHED.")

# CALCULATION OF CONSTANTS FOR SIMULATION DIFFERENTIAL EQUATIONS OF MOTION
TEMP1 = (LAST_CG_FROM_NOSE - WING_CENTER_OF_PRESSURE) / REFERENCE_DIAMETER 
TEMP2 = (LAST_CG_FROM_NOSE - CENTER_OF_DEFLECTION_FROM_NOSE) / REFERENCE_DIAMETER
TEMP3 = (LAST_CG_FROM_NOSE - BODY_CENTER_OF_PRESSURE) / REFERENCE_DIAMETER
TEMP4 = (LAST_CG_FROM_NOSE - NOSE_CENTER_OF_PRESSURE) / REFERENCE_DIAMETER
Y1 = 2 * TEMP4 + 8 * WING_AREA * TEMP1 / (BETA * REFERENCE_AREA) + 8 * TAIL_AREA * TEMP2 / (BETA * REFERENCE_AREA)
Y2 = 1.5 * PLANFORM_AREA * TEMP3 / REFERENCE_AREA
Y3 = 8 * TAIL_AREA * TEMP2 * FIN_DEFLECTION_RADIANS / (BETA * REFERENCE_AREA)

ALPHA_TRIM = (-Y1 - np.sqrt((Y1 ** 2) - 4 * Y2 * Y3)) / (2 * Y2)
CNA = 2 + 1.5 * PLANFORM_AREA * ALPHA_TRIM / REFERENCE_AREA + 8 * WING_AREA / (BETA * REFERENCE_AREA) + 8 * TAIL_AREA / (BETA * REFERENCE_AREA)
CND = 8 * TAIL_AREA / (BETA * REFERENCE_AREA)
ZA = -1 * DYNAMIC_PRESSURE * REFERENCE_AREA * CNA / (MASS * AIRSPEED)
ZD = -1 * DYNAMIC_PRESSURE * REFERENCE_AREA * CND / (MASS * AIRSPEED)
CMAP = 2 * TEMP4 + 1.5 * PLANFORM_AREA * ALPHA_TRIM * TEMP3 / REFERENCE_AREA + 8 * WING_AREA * TEMP1 / (BETA * REFERENCE_AREA)
CMA = CMAP + 8 * TAIL_AREA * TEMP2 / (BETA * REFERENCE_AREA)
CMD = 8 * TAIL_AREA * TEMP2 / (BETA * REFERENCE_AREA)
MA = DYNAMIC_PRESSURE * REFERENCE_AREA * REFERENCE_DIAMETER * CMA / TRANSVERSE_MOMENT_OF_INERTIA
MD = DYNAMIC_PRESSURE * REFERENCE_AREA * REFERENCE_DIAMETER * CMD / TRANSVERSE_MOMENT_OF_INERTIA

OMEGA_Z = np.sqrt((MA * ZD - MD * ZA) / ZD)
OMEGA_AF = np.sqrt(-1 * MA)
ZETA_AF = ZA * OMEGA_AF / (2 * MA)
K1 = -1 * AIRSPEED * ((MA * ZD - ZA * MD) / (1845 * MA))
K2 = K1
K3 = 1845 * K1 / AIRSPEED
TA = MD / (MA * ZD - ZA * MD)

# SIMULATION DIFFERENTIAL EQUATIONS OF MOTION PARAMETERS
E = 0.0
EDOT = 0.0

TOF = 0.0 # Seconds.
THETA_DOT = 0.0 # Radians per second.
THETA = 0.0 # Radians.
NORMAL_ACCEL = 0.0 # Meters per second squared.
POSITION = ALTITUDE # Meters.
ALPHA_DOT = 0.0 # Radians per second.
ALPHA = 0.0 # Radians.

DIFFERENTIAL_EQNS_OF_MOTION_DICT = {
	"TOF": [],
	"THETA_DOT": [],
	"THETA": [],
	"NORMAL_ACCEL": [],
	"POSITION": [],
	"ALPHA_DOT": [],
	"ALPHA": []
}

while TOF <= MAX_TIME:

	# ITERATE TIME OF FLIGHT
	TOF += TIME_STEP

	EDOTDOT = (OMEGA_AF ** 2) * (FIN_DEFLECTION_DEGREES - E - 2 * ZETA_AF * EDOT / OMEGA_AF)
	E += EDOT * TIME_STEP
	EDOT += EDOTDOT * TIME_STEP

	THETA_DOT = K3 * (E + TA * EDOT)
	THETA += THETA_DOT * TIME_STEP
	NORMAL_ACCEL = K1 * (E - (EDOTDOT / (OMEGA_Z ** 2))) * STANDARD_GRAVITY
	POSITION += (AIRSPEED + (NORMAL_ACCEL * TIME_STEP)) * TIME_STEP
	ALPHA_DOT = THETA_DOT - (NORMAL_ACCEL / AIRSPEED) * RAD_TO_DEG
	ALPHA += ALPHA_DOT * TIME_STEP

	# STORE DATA AT CURRENT CONDITIONS
	DIFFERENTIAL_EQNS_OF_MOTION_DICT["TOF"].append(TOF)
	DIFFERENTIAL_EQNS_OF_MOTION_DICT["THETA_DOT"].append(THETA_DOT)
	DIFFERENTIAL_EQNS_OF_MOTION_DICT["THETA"].append(THETA)
	DIFFERENTIAL_EQNS_OF_MOTION_DICT["NORMAL_ACCEL"].append(NORMAL_ACCEL)
	DIFFERENTIAL_EQNS_OF_MOTION_DICT["POSITION"].append(POSITION)
	DIFFERENTIAL_EQNS_OF_MOTION_DICT["ALPHA_DOT"].append(ALPHA_DOT)
	DIFFERENTIAL_EQNS_OF_MOTION_DICT["ALPHA"].append(ALPHA)

# OUTPUT
print(f"DIFFERENTIAL EQUATIONS OF MOTION FINISHED.")

# PLOT
DF1 = pd.DataFrame(LINEAR_EQNS_OF_MOTION_DICT)
DF2 = pd.DataFrame(DIFFERENTIAL_EQNS_OF_MOTION_DICT)

FIGURE = plt.figure()

THETA_DOT_PLOT = FIGURE.add_subplot(231)
THETA_DOT_PLOT.set_xlabel("TIME OF FLIGHT")
THETA_DOT_PLOT.set_title("THETA_DOT - DEGREES PER SECOND")
THETA_DOT_PLOT.plot(DF1.iloc[:]["TOF"], DF1.iloc[:]["THETA_DOT"] * RAD_TO_DEG, color="b", label="LINEAR AIRFRAME")
THETA_DOT_PLOT.plot(DF2.iloc[:]["TOF"], DF2.iloc[:]["THETA_DOT"] / 1.0, color="r", label="DIFFERENTIAL AIRFRAME")
THETA_DOT_PLOT.legend(fontsize="small")

THETA_PLOT = FIGURE.add_subplot(232)
THETA_PLOT.set_xlabel("TIME OF FLIGHT")
THETA_PLOT.set_title("THETA - DEGREES")
THETA_PLOT.plot(DF1.iloc[:]["TOF"], DF1.iloc[:]["THETA"] * RAD_TO_DEG, color="b", label="LINEAR AIRFRAME")
THETA_PLOT.plot(DF2.iloc[:]["TOF"], DF2.iloc[:]["THETA"] / 1.0, color="r", label="DIFFERENTIAL AIRFRAME")
THETA_PLOT.legend(fontsize="small")

NORMAL_ACCEL_PLOT = FIGURE.add_subplot(233)
NORMAL_ACCEL_PLOT.set_xlabel("TIME OF FLIGHT")
NORMAL_ACCEL_PLOT.set_title("NORMAL ACCEL - (M/S^2)")
NORMAL_ACCEL_PLOT.plot(DF1.iloc[:]["TOF"], DF1.iloc[:]["NORMAL_ACCEL"], color="b", label="LINEAR AIRFRAME")
NORMAL_ACCEL_PLOT.plot(DF2.iloc[:]["TOF"], DF2.iloc[:]["NORMAL_ACCEL"], color="r", label="DIFFERENTIAL AIRFRAME")
NORMAL_ACCEL_PLOT.legend(fontsize="small")

ALTITUDE = FIGURE.add_subplot(234)
ALTITUDE.set_xlabel("TIME OF FLIGHT")
ALTITUDE.set_title("ALTITUDE - METERS")
ALTITUDE.plot(DF1.iloc[:]["TOF"], DF1.iloc[:]["POSITION"], color="b", label="LINEAR AIRFRAME")
ALTITUDE.plot(DF2.iloc[:]["TOF"], DF2.iloc[:]["POSITION"], color="r", label="DIFFERENTIAL AIRFRAME")
ALTITUDE.legend(fontsize="small")

ALPHA = FIGURE.add_subplot(235)
ALPHA.set_xlabel("TIME OF FLIGHT")
ALPHA.set_title("ALPHA - DEGREES")
ALPHA.plot(DF1.iloc[:]["TOF"], DF1.iloc[:]["ALPHA"] * RAD_TO_DEG, color="b", label="LINEAR AIRFRAME")
# ALPHA.plot(DF1.iloc[:]["TOF"], DF1.iloc[:]["ALPHA"], color="b", label="LINEAR AIRFRAME")
ALPHA.plot(DF2.iloc[:]["TOF"], DF2.iloc[:]["ALPHA"], color="r", label="DIFFERENTIAL AIRFRAME")
ALPHA.legend(fontsize="small")

ALPHA_DOT = FIGURE.add_subplot(236)
ALPHA_DOT.set_xlabel("TIME OF FLIGHT")
ALPHA_DOT.set_title("ALPHA DOT - DEGREES PER SECOND")
ALPHA_DOT.plot(DF1.iloc[:]["TOF"], DF1.iloc[:]["ALPHA_DOT"] * RAD_TO_DEG, color="b", label="LINEAR AIRFRAME", linestyle="dotted")
ALPHA_DOT.plot(DF2.iloc[:]["TOF"], DF2.iloc[:]["ALPHA_DOT"], color="r", label="DIFFERENTIAL AIRFRAME", linestyle="dotted")
ALPHA_DOT.legend(fontsize="small")

# plt.get_current_fig_manager().full_screen_toggle()
plt.show()